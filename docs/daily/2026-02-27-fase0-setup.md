# Daily — Fase 0: Setup del Monorepo
**Fecha:** 2026-02-27
**Fase:** 0 — Setup
**Milestone:** `docker-compose up` funciona con todos los servicios

---

## Resumen ejecutivo

Se inicializó el monorepo completo del CV Simulator desde cero. El proyecto pasó de tener solo documentación de arquitectura a tener una base funcional con backend, frontend, infraestructura y CI/CD configurados. El milestone de esta fase — que `docker-compose up` levante todos los servicios — está listo para ser verificado.

---

## Archivos creados

### Raíz del monorepo

| Archivo | Propósito |
|---|---|
| `.gitignore` | Excluye bytecode Python, node_modules, .env, artefactos de build y configuraciones de IDE |
| `.env.example` | Plantilla canónica de variables de entorno para todos los servicios. Los devs hacen `cp .env.example .env` |
| `Makefile` | Comandos de conveniencia: `make up`, `make down`, `make test`, `make migrate`, `make lint`, `make shell-api`, `make shell-db` |
| `docker-compose.yml` | Orquestación completa de desarrollo con todos los servicios, health checks y red compartida |
| `docker-compose.prod.yml` | Override de producción: elimina bind-mounts, activa `restart: always`, desactiva DEBUG |

### Backend — `backend/`

| Archivo | Propósito |
|---|---|
| `pyproject.toml` | Dependencias del proyecto: FastAPI, SQLAlchemy async, Pydantic v2, Alembic, Redis, aio-pika, Celery, Anthropic SDK, pytest, ruff |
| `Dockerfile` | Build multi-stage: stage `builder` instala deps con pip, stage `production` corre con usuario no-root `appuser` sobre `python:3.12-slim` |
| `alembic.ini` | Configuración de Alembic apuntando a `./alembic/` |
| `alembic/env.py` | Configuración async de Alembic usando `async_engine_from_config`. Importa `Base.metadata` para autogenerate |
| `alembic/versions/.gitkeep` | Mantiene el directorio de migraciones en git |
| `src/__init__.py` | Marca `src/` como paquete Python |
| `src/config.py` | `Settings` con Pydantic BaseSettings. Lee variables del `.env`. Expone propiedades: `database_url`, `redis_url`, `rabbitmq_url` |
| `src/main.py` | Entrypoint FastAPI. Lifespan: conecta PostgreSQL, Redis y RabbitMQ al startup, desconecta al shutdown. Expone `GET /health` |
| `src/worker.py` | Instancia Celery con broker RabbitMQ y backend Redis |
| `src/tasks.py` | Task de prueba `tasks.ping` → retorna `"pong"` |
| `src/shared/__init__.py` | Marca shared como paquete |
| `src/shared/database.py` | `AsyncEngine` + `AsyncSessionLocal` (async_sessionmaker). `Base` declarativa. Dependency `get_db()` con commit/rollback automático |
| `src/shared/redis_client.py` | `ConnectionPool` singleton. `get_redis()` retorna cliente async. `close_redis()` para cleanup |
| `src/shared/rabbitmq.py` | Conexión robusta con `aio_pika.connect_robust`. `get_channel()` con QoS. `publish()` publica a un exchange TOPIC con mensajes persistentes. `close_rabbitmq()` para cleanup |
| `tests/__init__.py` | Marca tests como paquete |
| `tests/conftest.py` | Fixture `client`: `AsyncClient` con `ASGITransport` para tests sin levantar servidor real |
| `tests/test_health.py` | Tests del endpoint `/health`: verifica status 200, campo `"status": "ok"` y `"version": "0.1.0"` |

### Frontend — `frontend/`

| Archivo | Propósito |
|---|---|
| `package.json` | React 18 + TypeScript + Vite. Scripts: `dev`, `build`, `lint` |
| `vite.config.ts` | Configuración Vite con proxy `/api` → `localhost:8000` para desarrollo local |
| `tsconfig.json` | Config TypeScript raíz con referencias a `tsconfig.app.json` y `tsconfig.node.json` |
| `tsconfig.app.json` | Config strict para el código de la app: ES2020, JSX react-jsx, strict mode |
| `tsconfig.node.json` | Config para archivos de config de Vite (ES2022) |
| `index.html` | Entry point HTML con `<div id="root">` |
| `src/main.tsx` | Root React con `StrictMode` |
| `src/App.tsx` | Página placeholder "CV Simulator — Coming Soon" |
| `Dockerfile` | Multi-stage: `node:22-alpine` builder ejecuta `npm run build` → `nginx:alpine` sirve el `dist/`. Configurado con SPA fallback (`try_files $uri /index.html`) |

### Infraestructura — `infra/`

| Archivo | Propósito |
|---|---|
| `infra/docker/nginx/nginx.conf` | Proxy inverso: `/api/` → `api:8000`, `/health` → `api:8000/health`, `/` → `frontend:80` |
| `infra/docker/postgres/init.sql` | Inicialización de PostgreSQL: activa extensiones `uuid-ossp` (UUIDs nativos) y `pg_trgm` (búsqueda por similitud) |

### CI/CD — `.github/`

| Archivo | Propósito |
|---|---|
| `.github/workflows/ci.yml` | Pipeline GitHub Actions con 3 jobs: `lint-backend` (ruff), `test-backend` (pytest con servicios postgres + redis), `build-images` (build Docker de backend y frontend) |

---

## Servicios Docker Compose

| Servicio | Puerto expuesto | Imagen | Health check |
|---|---|---|---|
| `api` | 8000 | Build local `./backend` | `GET /health` |
| `celery-worker` | — | Build local `./backend` | — |
| `frontend` | 3000 | Build local `./frontend` | — |
| `postgres` | 5432 | `postgres:16-alpine` | `pg_isready` |
| `redis` | 6379 | `redis:7-alpine` | `redis-cli ping` |
| `rabbitmq` | 5672 / 15672 | `rabbitmq:3.13-management-alpine` | `rabbitmq-diagnostics` |
| `nginx` | 80 | `nginx:alpine` | — |

**Red:** `cv-simulator-network` (bridge)
**Volúmenes nombrados:** `postgres_data`, `redis_data`, `rabbitmq_data`

---

## Decisiones técnicas

### 1. Multi-stage Docker builds
Se usaron builds multi-stage en backend y frontend para separar la instalación de dependencias de la imagen de producción. Resultado: imágenes más pequeñas y sin herramientas de build en producción.

### 2. Usuario no-root en backend
El contenedor de producción corre con `appuser:appgroup` en lugar de `root`. Esto es una práctica de seguridad estándar en contenedores.

### 3. Conexiones robustas con aio-pika
Se usa `connect_robust` para RabbitMQ, que reconecta automáticamente si el broker se cae temporalmente. Útil durante el startup cuando los servicios se están levantando.

### 4. Health checks en Docker Compose
Todos los servicios de datos (postgres, redis, rabbitmq) tienen health checks. El servicio `api` tiene `depends_on` con `condition: service_healthy` para garantizar que la app solo arranca cuando las bases de datos están listas.

### 5. Alembic con async engine
La configuración de Alembic usa `async_engine_from_config` con `asyncio.run()` en el `env.py` para ser compatible con SQLAlchemy async y asyncpg.

### 6. Settings con Pydantic BaseSettings
Las variables de entorno se leen automáticamente del `.env` y del entorno. Los valores por defecto permiten correr localmente sin `.env`. Las propiedades `database_url`, `redis_url` y `rabbitmq_url` se construyen dinámicamente.

### 7. Celery con RabbitMQ como broker y Redis como backend
RabbitMQ se usa como broker de tareas (más robusto para mensajería) y Redis como backend de resultados (más rápido para consultar el estado de las tareas).

---

## Comandos de verificación

```bash
# 1. Copiar variables de entorno
cp .env.example .env

# 2. Levantar todos los servicios
make up
# o: docker compose up --build

# 3. Verificar API
curl http://localhost:8000/health
# Respuesta esperada:
# {"status":"ok","version":"0.1.0","services":{"postgres":"ok","redis":"ok","rabbitmq":"ok"}}

# 4. Verificar Frontend
open http://localhost:3000
# Debe mostrar: "CV Simulator — Coming Soon"

# 5. Verificar RabbitMQ Management UI
open http://localhost:15672
# Usuario: cv_user / Contraseña: cv_password

# 6. Verificar todos los contenedores corriendo
docker compose ps

# 7. Correr tests
make test
# pytest tests/ -v → 2 tests deben pasar

# 8. Lint
make lint
# ruff check src/ tests/ → sin errores
```

---

## Estructura final del proyecto

```
portfolio-CV/
├── .env.example
├── .gitignore
├── .github/workflows/ci.yml
├── Makefile
├── docker-compose.yml
├── docker-compose.prod.yml
├── cv-simulator-architecture.md
├── docs/daily/2026-02-27-fase0-setup.md
├── backend/
│   ├── Dockerfile
│   ├── pyproject.toml
│   ├── alembic.ini
│   ├── alembic/
│   │   ├── env.py
│   │   └── versions/
│   ├── src/
│   │   ├── __init__.py
│   │   ├── config.py
│   │   ├── main.py
│   │   ├── worker.py
│   │   ├── tasks.py
│   │   └── shared/
│   │       ├── __init__.py
│   │       ├── database.py
│   │       ├── redis_client.py
│   │       └── rabbitmq.py
│   └── tests/
│       ├── __init__.py
│       ├── conftest.py
│       └── test_health.py
├── frontend/
│   ├── Dockerfile
│   ├── package.json
│   ├── vite.config.ts
│   ├── tsconfig.json
│   ├── tsconfig.app.json
│   ├── tsconfig.node.json
│   ├── index.html
│   └── src/
│       ├── main.tsx
│       └── App.tsx
└── infra/
    └── docker/
        ├── nginx/nginx.conf
        └── postgres/init.sql
```

---

## Próximos pasos — Fase 1: Auth + Users (Semana 2)

- Slice `users/register/`: endpoint POST `/api/users/register`, command, handler, repository
- Slice `users/login/`: endpoint POST `/api/users/login`, JWT response
- Slice `users/get_profile/`: endpoint GET `/api/users/me` (requiere JWT)
- Modelo `User` en SQLAlchemy + primera migración Alembic
- Middleware de autenticación JWT en `shared/auth/`
- Tests de integración para register, login y perfil

**Estimado:** 25 horas
