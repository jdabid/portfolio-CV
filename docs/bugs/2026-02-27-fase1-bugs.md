# Bugs — Fase 1 (Auth + Users)

**Fecha:** 2026-02-27

---

## Bug 1: passlib incompatible con bcrypt >= 4.1

### Síntoma
```
ValueError: password cannot be longer than 72 bytes, truncate manually if necessary
```
Ocurre al llamar `POST /api/users/register`.

### Causa raíz
`passlib` (última release 2020) tiene un bug de detección interna con `bcrypt >= 4.1`.
Al inicializar `CryptContext(schemes=["bcrypt"])`, passlib ejecuta un test interno
(`detect_wrap_bug`) que falla con versiones modernas de bcrypt.

### Solución
Reemplazar passlib por bcrypt directo:

**Antes (broken):**
```python
from passlib.context import CryptContext
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
```

**Después (working):**
```python
import bcrypt

def hash_password(plain: str) -> str:
    return bcrypt.hashpw(plain.encode(), bcrypt.gensalt()).decode()

def verify_password(plain: str, hashed: str) -> bool:
    return bcrypt.checkpw(plain.encode(), hashed.encode())
```

**pyproject.toml:** cambiar `passlib[bcrypt]>=1.7.4` → `bcrypt>=4.0.0`

### Sugerencia
No usar passlib en proyectos nuevos. Está unmaintained desde 2020.
Usar bcrypt directamente o argon2-cffi como alternativas.

---

## Bug 2: Alembic script.py.mako faltante

### Síntoma
```
FileNotFoundError: No such file or directory: 'alembic/script.py.mako'
```
Ocurre al ejecutar `alembic revision --autogenerate`.

### Causa raíz
El setup inicial de Alembic (Fase 0) creó `alembic/env.py` y `alembic/versions/`
pero no incluyó el template `script.py.mako` que Alembic necesita para generar
archivos de migración.

### Solución
Crear `backend/alembic/script.py.mako` con el template estándar de Alembic
(imports, revision identifiers, upgrade/downgrade functions).

### Sugerencia
Al inicializar Alembic, usar `alembic init alembic` que crea todos los archivos
necesarios automáticamente, o verificar que existan:
- `alembic.ini`
- `alembic/env.py`
- `alembic/script.py.mako` (este faltaba)
- `alembic/versions/`

---

## Bug 3: pytest-asyncio STRICT mode + async fixtures

### Síntoma
```
PytestRemovedIn9Warning: requested an async fixture 'setup_database' with autouse=True,
with no plugin or hook that handled it.
```
Todos los tests fallan con ERROR en setup.

### Causa raíz
pytest-asyncio >= 1.0 usa `STRICT` mode por defecto. En este modo, async fixtures
deben usar `@pytest_asyncio.fixture` en lugar de `@pytest.fixture`.
Además, `asyncio_mode = "auto"` en pyproject.toml no se aplica (STRICT overrides).

### Solución
1. Cambiar `@pytest.fixture` → `@pytest_asyncio.fixture` para todos los async fixtures
2. Mantener `@pytest.mark.asyncio` en las test functions

### Sugerencia
Considerar pinear `pytest-asyncio<1.0` si se quiere usar `asyncio_mode = "auto"`
y `@pytest.fixture` para async fixtures. O adoptar STRICT mode como estándar.

---

## Bug 4: Test engine con pool compartido entre event loops

### Síntoma
```
sqlalchemy.exc.OperationalError: connection was closed in a different event loop
```
El primer test pasa pero los siguientes fallan en `setup_database`.

### Causa raíz
El `test_engine` estaba creado a nivel de módulo (`create_async_engine(...)` fuera
de fixtures). pytest-asyncio STRICT crea un nuevo event loop por test. El engine y
su connection pool están ligados al primer event loop y fallan en los siguientes.

### Solución
Crear el engine dentro de un fixture con `poolclass=pool.NullPool`:

```python
@pytest_asyncio.fixture
async def db_engine():
    engine = create_async_engine(settings.database_url, poolclass=pool.NullPool)
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    yield engine
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)
    await engine.dispose()
```

`NullPool` crea una conexión nueva cada vez, evitando el problema de event loops.

### Sugerencia
Siempre usar `NullPool` en tests con pytest-asyncio para evitar conflictos de
connection pool entre event loops.
